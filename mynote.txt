---2018.07.20---
	1.zookeeper集群有问题,使用单机192.168.4.133:2181后Conf.java跑通
	2.Conf.java需要看一下,尤其CountDownLatch对线程同步
---2018.07.21---
	使用zookeepr开发分布式服务上下线感知(org.softcits.bigdata.zk01)
	DistributedServer演示服务上线后注册
	DistributedClient演示获取当前存活服务
	巧妙设计:
	1. 利用Zookeeper临时节点而不是永久节点,这样Zookeeper重启后节点信息不保存,服务启动后再重新注册
	2. 使用Zookeeper自增长id节点来避免服务注册冲突
	3. Zookeeper节点有两个属性,节点名(可以保存服务所在主机名)和节点数据(可以保存服务名)
	4. 利用Zookeeper的监听,通过重写Watcher的process方法来获取服务上下线时创建删除节点事件,从而重新获取Zookeeper节点注册的服务来动态感知服务。
		a.服务创建节点时->服务启动后连接Zookeeper然后创建节点
		b.服务删除节点时->服务因某种异常断开与Zookeeper连接,此时Zookeeper会自动删除此节点
	其中讲解了Deamon守护线程,即主线程结束后Deamon线程继续运行,不然普通方式创建子线程时,只要子线程不结束则主线程也不结束。
---2018.07.22---
	异常可以释放syncronized锁
	lock和syncronized区别
	1. Lock是个接口
	2. Lock必须手动释放锁而synchronized代码执行完成后就会释放锁
	3. Lock中有中断锁方法,即等待的获取锁的线程可以终止等待去做些别的事情
---2018.07.23---
	常用线程池：
		SingleThread--固定单线程在池子中,好处就是可以保证提交任务的顺序执行
		CachedThreadPool--缓冲线程池,可灵活回收空闲线程
		FixedThreadPool--创建固定线程数的线程池
		ScheduledThreadPool--支持延时或周期性的任务执行
	创建多线程时使用java.lang.Runable和 java.util.concurrent.Callable<V>区别
	1. Callbale中V call() throws Exception; 是有返回值(泛型)的,而Runable的run()方法没有返回值
---2018.07.25---
	多线程obj.notify和obj.wait使用的前提是加同一个对象锁synchronized(obj){obj.notify()/obj.wait()}
